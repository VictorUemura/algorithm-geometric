using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Linq;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Diagnostics;
using System.Text;

namespace ProcessamentoImagens
{
    public partial class frmPoligonosTransformacoes : Form
    {
        // --- Estrutura Auxiliar para Scanline ---
        private class EdgeInfoScanline
        {
            public int YMax { get; set; }
            public float XCurrent { get; set; }
            public float InverseSlope { get; set; }
            public EdgeInfoScanline(int yMax, float xStart, float invSlope) { YMax = yMax; XCurrent = xStart; InverseSlope = invSlope; }
        }

        // --- Variáveis de Estado ---
        private List<Poligono> listaPoligonos = new List<Poligono>();
        private List<Point> currentPolygonPoints = new List<Point>();
        private Bitmap drawingBitmap;
        private Graphics bitmapGraphics;
        private PointF centroDoPainel;
        private bool isDrawingPolygon = false;
        private bool needsRedraw = true;

        // Configurações
        private Color polygonDrawColor = Color.DarkSlateBlue;
        private Color currentPolygonDrawColor = Color.Crimson;
        private Color selectionHighlightColor = Color.LimeGreen;
        private Color fillColor = Color.MediumAquamarine;

        // --- Construtor e Ciclo de Vida ---
        public frmPoligonosTransformacoes() { InitializeComponent(); this.SetStyle(ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer, true); }
        private void frmPoligonosTransformacoes_Load(object sender, EventArgs e) { InitializeDrawingArea(); AttachEventHandlers(); ResetTransformationControls(); }
        private void frmPoligonosTransformacoes_FormClosing(object sender, FormClosingEventArgs e) { bitmapGraphics?.Dispose(); drawingBitmap?.Dispose(); }

        // --- Configuração Inicial e Redimensionamento ---
        private void InitializeDrawingArea() { if (panelDesenho.ClientSize.Width <= 0 || panelDesenho.ClientSize.Height <= 0) return; centroDoPainel = new PointF(panelDesenho.ClientSize.Width / 2f, panelDesenho.ClientSize.Height / 2f); Bitmap oldBitmap = drawingBitmap; Graphics oldGraphics = bitmapGraphics; drawingBitmap = new Bitmap(panelDesenho.ClientSize.Width, panelDesenho.ClientSize.Height, PixelFormat.Format32bppArgb); bitmapGraphics = Graphics.FromImage(drawingBitmap); bitmapGraphics.SmoothingMode = SmoothingMode.AntiAlias; bitmapGraphics.Clear(Color.White); oldGraphics?.Dispose(); oldBitmap?.Dispose(); panelDesenho.BackgroundImage = drawingBitmap; panelDesenho.BackgroundImageLayout = ImageLayout.None; needsRedraw = true; panelDesenho.Invalidate(); }
        private void panelDesenho_Resize(object sender, EventArgs e) { InitializeDrawingArea(); RebuildAndUpdateSelectedPolygons(); needsRedraw = true; panelDesenho.Invalidate(); }
        private void AttachEventHandlers() { this.panelDesenho.Paint += new System.Windows.Forms.PaintEventHandler(this.panelDesenho_Paint); this.panelDesenho.MouseClick += new System.Windows.Forms.MouseEventHandler(this.panelDesenho_MouseClick); this.panelDesenho.Resize += new System.EventHandler(this.panelDesenho_Resize); this.btnFinalizarConexoes.Click += new System.EventHandler(this.btnFinalizarConexoes_Click); this.btnFloodFill.Click += new System.EventHandler(this.btnFloodFill_Click); this.btnScanline.Click += new System.EventHandler(this.btnScanline_Click); this.btnRemoverSelecionados.Click += new System.EventHandler(this.btnRemoverSelecionados_Click); this.btnLimparTudo.Click += new System.EventHandler(this.btnLimparTudo_Click); this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.frmPoligonosTransformacoes_FormClosing); this.btnReflexaoVertical.Click += new System.EventHandler(this.TransformationUI_Changed); this.btnReflexaoHorizontal.Click += new System.EventHandler(this.TransformationUI_Changed); this.btnReflexaoConjunto.Click += new System.EventHandler(this.TransformationUI_Changed); this.numTranslacaoX.ValueChanged += new System.EventHandler(this.TransformationUI_Changed); this.numTranslacaoY.ValueChanged += new System.EventHandler(this.TransformationUI_Changed); this.numEscalaX.ValueChanged += new System.EventHandler(this.TransformationUI_Changed); this.numEscalaY.ValueChanged += new System.EventHandler(this.TransformationUI_Changed); this.numRotacaoEixo.ValueChanged += new System.EventHandler(this.TransformationUI_Changed); this.numRotacaoCentro.ValueChanged += new System.EventHandler(this.TransformationUI_Changed); this.numCisalhamentoX.ValueChanged += new System.EventHandler(this.TransformationUI_Changed); this.numCisalhamentoY.ValueChanged += new System.EventHandler(this.TransformationUI_Changed); this.btnReflexaoCentroVertical.Click += new System.EventHandler(this.btnReflexaoCentroVertical_Click); this.btnReflexaoCentroHorizontal.Click += new System.EventHandler(this.btnReflexaoCentroHorizontal_Click); this.btnReflexaoCentroOrigem.Click += new System.EventHandler(this.btnReflexaoCentroOrigem_Click); }

        // --- Desenho ---
        private void panelDesenho_Paint(object sender, PaintEventArgs e) { if (bitmapGraphics == null) { InitializeDrawingArea(); if (bitmapGraphics == null) return; } if (needsRedraw) { bitmapGraphics.Clear(Color.White); DrawPolygons(bitmapGraphics); DrawCurrentPolygon(bitmapGraphics); bitmapGraphics.FillEllipse(Brushes.Red, centroDoPainel.X - 3, centroDoPainel.Y - 3, 6, 6); needsRedraw = false; panelDesenho.Invalidate(); } }
        private void DrawPolygons(Graphics g) { if (g == null) return; foreach (CheckBox chk in flowLayoutPanelPoligonos.Controls.OfType<CheckBox>()) { if (chk.Tag is int index && index >= 0 && index < listaPoligonos.Count) { Poligono poly = listaPoligonos[index]; if (poly?.ListaVerticesAtuais != null && poly.ListaVerticesAtuais.Count >= 2) { Color color = polygonDrawColor; float width = 1f; if (chk.Checked) { color = selectionHighlightColor; width = 2f; } using (Pen pen = new Pen(color, width)) { try { PointF[] pointsF = poly.ListaVerticesAtuais.Select(p => new PointF(p.X, p.Y)).ToArray(); if (pointsF.Length >= 3) g.DrawPolygon(pen, pointsF); else if (pointsF.Length == 2) g.DrawLines(pen, pointsF); } catch (Exception ex) { Debug.WriteLine($"Erro ao desenhar polígono {index}: {ex.Message}"); } } } } } }
        private void DrawCurrentPolygon(Graphics g) { if (g == null) return; if (currentPolygonPoints.Count > 0) { using (Pen currentPen = new Pen(currentPolygonDrawColor, 1)) using (Brush currentBrush = new SolidBrush(currentPolygonDrawColor)) { foreach (Point p in currentPolygonPoints) { g.FillRectangle(currentBrush, p.X - 2, p.Y - 2, 5, 5); } if (currentPolygonPoints.Count >= 2) { PointF[] pointsF = currentPolygonPoints.Select(p => new PointF(p.X, p.Y)).ToArray(); g.DrawLines(currentPen, pointsF); } } } }

        // --- Criação de Polígonos ---
        private void panelDesenho_MouseClick(object sender, MouseEventArgs e) { if (e.Button == MouseButtons.Left) { if (!isDrawingPolygon) { isDrawingPolygon = true; currentPolygonPoints.Clear(); } currentPolygonPoints.Add(e.Location); needsRedraw = true; panelDesenho.Invalidate(); } else if (e.Button == MouseButtons.Right && isDrawingPolygon) { btnFinalizarConexoes_Click(sender, e); } }
        private void btnFinalizarConexoes_Click(object sender, EventArgs e) { if (currentPolygonPoints.Count >= 3) { try { var verticesFinais = new List<Point>(currentPolygonPoints); Poligono novoPoligono = new Poligono(verticesFinais); int newIndex = listaPoligonos.Count; listaPoligonos.Add(novoPoligono); CheckBox newCheckBox = new CheckBox { Text = $"P{newIndex + 1}", Tag = newIndex, AutoSize = true, Enabled = true, Checked = false, Margin = new Padding(5) }; newCheckBox.CheckedChanged += (s, args) => { needsRedraw = true; panelDesenho.Invalidate(); }; flowLayoutPanelPoligonos.Controls.Add(newCheckBox); currentPolygonPoints.Clear(); isDrawingPolygon = false; ResetTransformationControls(); needsRedraw = true; panelDesenho.Invalidate(); } catch (ArgumentException ex) { MessageBox.Show(ex.Message, "Erro ao Criar Polígono", MessageBoxButtons.OK, MessageBoxIcon.Error); currentPolygonPoints.Clear(); isDrawingPolygon = false; needsRedraw = true; panelDesenho.Invalidate(); } } else { MessageBox.Show("Um polígono precisa de pelo menos 3 vértices para ser finalizado.", "Aviso", MessageBoxButtons.OK, MessageBoxIcon.Information); } }

        // --- Remover e Limpar Polígonos ---
        private void btnRemoverSelecionados_Click(object sender, EventArgs e) { List<int> indicesParaRemover = new List<int>(); foreach (CheckBox chk in flowLayoutPanelPoligonos.Controls.OfType<CheckBox>()) { if (chk.Checked && chk.Tag is int index) { indicesParaRemover.Add(index); } } if (indicesParaRemover.Count == 0) { MessageBox.Show("Nenhum polígono selecionado para remover.", "Aviso", MessageBoxButtons.OK, MessageBoxIcon.Information); return; } indicesParaRemover.Sort((a, b) => b.CompareTo(a)); foreach (int index in indicesParaRemover) { if (index >= 0 && index < listaPoligonos.Count) { listaPoligonos.RemoveAt(index); if (index < flowLayoutPanelPoligonos.Controls.Count) flowLayoutPanelPoligonos.Controls.RemoveAt(index); } } for (int i = 0; i < flowLayoutPanelPoligonos.Controls.Count; i++) { if (flowLayoutPanelPoligonos.Controls[i] is CheckBox chk) { chk.Tag = i; chk.Text = $"P{i + 1}"; } } currentPolygonPoints.Clear(); isDrawingPolygon = false; ResetTransformationControls(); needsRedraw = true; panelDesenho.Invalidate(); }
        private void btnLimparTudo_Click(object sender, EventArgs e) { if (listaPoligonos.Count == 0 && currentPolygonPoints.Count == 0) { return; } var confirmResult = MessageBox.Show("Tem certeza que deseja remover TODOS os polígonos e limpar a área de desenho?", "Confirmar Limpeza Total", MessageBoxButtons.YesNo, MessageBoxIcon.Warning); if (confirmResult == DialogResult.Yes) { listaPoligonos.Clear(); flowLayoutPanelPoligonos.Controls.Clear(); currentPolygonPoints.Clear(); isDrawingPolygon = false; ResetTransformationControls(); needsRedraw = true; panelDesenho.Invalidate(); } }
        private void ResetTransformationControls() { numTranslacaoX.ValueChanged -= TransformationUI_Changed; numTranslacaoY.ValueChanged -= TransformationUI_Changed; numEscalaX.ValueChanged -= TransformationUI_Changed; numEscalaY.ValueChanged -= TransformationUI_Changed; numRotacaoEixo.ValueChanged -= TransformationUI_Changed; numRotacaoCentro.ValueChanged -= TransformationUI_Changed; numCisalhamentoX.ValueChanged -= TransformationUI_Changed; numCisalhamentoY.ValueChanged -= TransformationUI_Changed; numTranslacaoX.Value = 0; numTranslacaoY.Value = 0; numEscalaX.Value = 1; numEscalaY.Value = 1; numRotacaoEixo.Value = 0; numRotacaoCentro.Value = 0; numCisalhamentoX.Value = 0; numCisalhamentoY.Value = 0; numTranslacaoX.ValueChanged += TransformationUI_Changed; numTranslacaoY.ValueChanged += TransformationUI_Changed; numEscalaX.ValueChanged += TransformationUI_Changed; numEscalaY.ValueChanged += TransformationUI_Changed; numRotacaoEixo.ValueChanged += TransformationUI_Changed; numRotacaoCentro.ValueChanged += TransformationUI_Changed; numCisalhamentoX.ValueChanged += TransformationUI_Changed; numCisalhamentoY.ValueChanged += TransformationUI_Changed; }

        // --- Lógica de Transformação ---
        private void TransformationUI_Changed(object sender, EventArgs e) { bool isAxisReflectionClick = (sender == btnReflexaoVertical || sender == btnReflexaoHorizontal || sender == btnReflexaoConjunto); if (isAxisReflectionClick && sender is Button btnReflectAxis) { foreach (CheckBox chk in flowLayoutPanelPoligonos.Controls.OfType<CheckBox>()) { if (chk.Checked && chk.Tag is int index && index >= 0 && index < listaPoligonos.Count) { Poligono poly = listaPoligonos[index]; if (btnReflectAxis == btnReflexaoVertical) poly.ToggleReflectionY(); else if (btnReflectAxis == btnReflexaoHorizontal) poly.ToggleReflectionX(); else if (btnReflectAxis == btnReflexaoConjunto) poly.ToggleReflectionOrigin(); } } } RebuildAndUpdateSelectedPolygons(); }
        private void btnReflexaoCentroVertical_Click(object sender, EventArgs e) { ApplyCenterReflectionToggle(poly => poly.ToggleCenterReflectionX()); }
        private void btnReflexaoCentroHorizontal_Click(object sender, EventArgs e) { ApplyCenterReflectionToggle(poly => poly.ToggleCenterReflectionY()); }
        private void btnReflexaoCentroOrigem_Click(object sender, EventArgs e) { ApplyCenterReflectionToggle(poly => poly.ToggleCenterReflectionOrigin()); }
        private void ApplyCenterReflectionToggle(Action<Poligono> toggleAction) { bool changed = false; foreach (CheckBox chk in flowLayoutPanelPoligonos.Controls.OfType<CheckBox>()) { if (chk.Checked && chk.Tag is int index && index >= 0 && index < listaPoligonos.Count) { Poligono poly = listaPoligonos[index]; toggleAction(poly); changed = true; } } if (changed) { RebuildAndUpdateSelectedPolygons(); } else { MessageBox.Show("Nenhum polígono selecionado para aplicar a reflexão central.", "Aviso", MessageBoxButtons.OK, MessageBoxIcon.Information); } }
        private void RebuildAndUpdateSelectedPolygons() { float tx = (float)numTranslacaoX.Value; float ty = (float)numTranslacaoY.Value; float sx = (float)numEscalaX.Value; float sy = (float)numEscalaY.Value; float rEixo = (float)numRotacaoEixo.Value; float rCentro = (float)numRotacaoCentro.Value; float shx = (float)numCisalhamentoX.Value; float shy = (float)numCisalhamentoY.Value; centroDoPainel = new PointF(panelDesenho.ClientSize.Width / 2f, panelDesenho.ClientSize.Height / 2f); foreach (CheckBox chk in flowLayoutPanelPoligonos.Controls.OfType<CheckBox>()) { if (chk.Checked && chk.Tag is int index && index >= 0 && index < listaPoligonos.Count) { Poligono poly = listaPoligonos[index]; poly.ResetMatrix(); PointF cOrig = CalculateCentroidFromList(poly.ListaVerticesOriginais); PointF cPanel = this.centroDoPainel; poly.Translate(-cOrig.X, -cOrig.Y, MatrixOrder.Append); if (sx != 1 || sy != 1) poly.Scale(sx, sy, PointF.Empty, MatrixOrder.Append); if (shx != 0 || shy != 0) poly.Shear(shx, shy, PointF.Empty, MatrixOrder.Append); if (poly.CurrentReflectX != 1f || poly.CurrentReflectY != 1f) poly.ApplyReflectionMatrix(poly.CurrentReflectX, poly.CurrentReflectY, PointF.Empty, MatrixOrder.Append); if (rEixo != 0) poly.Rotate(rEixo, PointF.Empty, MatrixOrder.Append); poly.Translate(cOrig.X, cOrig.Y, MatrixOrder.Append); if (rCentro != 0) poly.Rotate(rCentro, cPanel, MatrixOrder.Append); if (poly.CenterReflectX != 1f || poly.CenterReflectY != 1f) { poly.ApplyReflectionMatrix(poly.CenterReflectX, poly.CenterReflectY, cPanel, MatrixOrder.Append); } if (tx != 0 || ty != 0) poly.Translate(tx, ty, MatrixOrder.Append); poly.UpdateVerticesAtuais(); } } needsRedraw = true; panelDesenho.Invalidate(); }

        // Calcula o centroide dos vértices ORIGINAIS (para transformações relativas ao centro)
        private PointF CalculateCentroidFromList(List<Point> pointList)
        {
            if (pointList == null || pointList.Count == 0) return PointF.Empty;

            // >>>>>>>> VERIFIQUE AQUI: Declaração de centerY <<<<<<<<<<
            double accumulatedArea = 0.0; double centerX = 0.0; double centerY = 0.0;

            for (int i = 0, j = pointList.Count - 1; i < pointList.Count; j = i++)
            {
                double temp = (double)pointList[i].X * pointList[j].Y - (double)pointList[j].X * pointList[i].Y;
                accumulatedArea += temp;
                centerX += (pointList[i].X + pointList[j].X) * temp;
                // >>>>>>>> VERIFIQUE AQUI: Uso de centerY <<<<<<<<<<
                centerY += (pointList[i].Y + pointList[j].Y) * temp;
            }
            if (Math.Abs(accumulatedArea) < 1E-7)
            {
                if (!pointList.Any()) return PointF.Empty;
                return new PointF((float)pointList.Average(p => p.X), (float)pointList.Average(p => p.Y));
            }

            accumulatedArea *= 3.0;

            // >>>>>>>> VERIFIQUE AQUI: Uso de centerY <<<<<<<<<<
            if (Math.Abs(accumulatedArea) < 1E-7 || double.IsNaN(centerX / accumulatedArea) || double.IsNaN(centerY / accumulatedArea) || double.IsInfinity(centerX / accumulatedArea) || double.IsInfinity(centerY / accumulatedArea))
            {
                Debug.WriteLine("Aviso: Divisão por zero ou resultado inválido/infinito ao calcular centroide original.");
                if (!pointList.Any()) return PointF.Empty;
                return new PointF((float)pointList.Average(p => p.X), (float)pointList.Average(p => p.Y));
            }
            // >>>>>>>> VERIFIQUE AQUI: Uso de centerY <<<<<<<<<<
            return new PointF((float)(centerX / accumulatedArea), (float)(centerY / accumulatedArea));
        }


        // --- Lógica de Preenchimento ---
        private void btnFloodFill_Click(object sender, EventArgs e) { if (drawingBitmap == null) return; bool filledAny = false; foreach (CheckBox chk in flowLayoutPanelPoligonos.Controls.OfType<CheckBox>()) { if (chk.Checked && chk.Tag is int index && index >= 0 && index < listaPoligonos.Count) { Poligono poly = listaPoligonos[index]; if (poly?.ListaVerticesAtuais != null && poly.ListaVerticesAtuais.Count >= 3) { PointF centroidF = poly.CalculateCurrentCentroid(); if (!centroidF.IsEmpty) { Point startPoint = Point.Round(centroidF); if (startPoint.X >= 0 && startPoint.X < drawingBitmap.Width && startPoint.Y >= 0 && startPoint.Y < drawingBitmap.Height) { PerformFloodFill(startPoint); filledAny = true; } else { Debug.WriteLine($"Centroide fora dos limites para P{index + 1} ({startPoint})."); } } else { Debug.WriteLine($"Centroide inválido para P{index + 1}."); } } } } if (filledAny) { panelDesenho.Invalidate(); } else { MessageBox.Show("Nenhum polígono válido selecionado ou centroide inválido/fora dos limites.", "Aviso de Preenchimento", MessageBoxButtons.OK, MessageBoxIcon.Information); } }
        private void PerformFloodFill(Point startPoint) { if (drawingBitmap == null) return; Color targetColor; try { targetColor = drawingBitmap.GetPixel(startPoint.X, startPoint.Y); } catch (Exception ex) { Debug.WriteLine($"Erro ao obter cor inicial para Flood Fill: {ex.Message}"); return; } if (targetColor.ToArgb() == fillColor.ToArgb()) { return; } int width = drawingBitmap.Width; int height = drawingBitmap.Height; BitmapData bmpData = null; try { bmpData = drawingBitmap.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadWrite, drawingBitmap.PixelFormat); int bytesPerPixel = Image.GetPixelFormatSize(drawingBitmap.PixelFormat) / 8; if (bytesPerPixel != 4) { throw new NotSupportedException("Flood Fill implementado apenas para 32bppArgb."); } int stride = bmpData.Stride; IntPtr ptr = bmpData.Scan0; int byteCount = Math.Abs(stride) * height; byte[] pixels = new byte[byteCount]; Marshal.Copy(ptr, pixels, 0, byteCount); int targetArgb = targetColor.ToArgb(); int fillArgb = fillColor.ToArgb(); byte[] fillBytes = BitConverter.GetBytes(fillArgb); Queue<Point> checkQueue = new Queue<Point>(); checkQueue.Enqueue(startPoint); while (checkQueue.Count > 0) { Point current = checkQueue.Dequeue(); int x = current.X; int y = current.Y; if (x < 0 || x >= width || y < 0 || y >= height) continue; int byteIndex = y * stride + x * bytesPerPixel; if (byteIndex < 0 || byteIndex + bytesPerPixel > byteCount) continue; int currentArgb = BitConverter.ToInt32(pixels, byteIndex); if (currentArgb == targetArgb) { Buffer.BlockCopy(fillBytes, 0, pixels, byteIndex, bytesPerPixel); checkQueue.Enqueue(new Point(x + 1, y)); checkQueue.Enqueue(new Point(x - 1, y)); checkQueue.Enqueue(new Point(x, y + 1)); checkQueue.Enqueue(new Point(x, y - 1)); } } Marshal.Copy(pixels, 0, ptr, byteCount); } catch (Exception ex) { Debug.WriteLine($"Erro durante Flood Fill: {ex.Message}\n{ex.StackTrace}"); MessageBox.Show($"Erro no Flood Fill: {ex.Message}", "Erro", MessageBoxButtons.OK, MessageBoxIcon.Error); } finally { if (bmpData != null) { drawingBitmap.UnlockBits(bmpData); } } }
        private void btnScanline_Click(object sender, EventArgs e) { if (drawingBitmap == null) return; bool filledAny = false; foreach (CheckBox chk in flowLayoutPanelPoligonos.Controls.OfType<CheckBox>()) { if (chk.Checked && chk.Tag is int index && index >= 0 && index < listaPoligonos.Count) { Poligono poly = listaPoligonos[index]; if (poly?.ListaVerticesAtuais != null && poly.ListaVerticesAtuais.Count >= 3) { PerformScanlineFill(poly.ListaVerticesAtuais); filledAny = true; } } } if (filledAny) { panelDesenho.Invalidate(); } else { MessageBox.Show("Nenhum polígono válido selecionado para preenchimento Scanline.", "Aviso Scanline", MessageBoxButtons.OK, MessageBoxIcon.Information); } }
        private void PerformScanlineFill(List<Point> polygonVertices) { if (drawingBitmap == null || polygonVertices == null || polygonVertices.Count < 3) return; int width = drawingBitmap.Width; int height = drawingBitmap.Height; BitmapData bmpData = null; try { int yMinGlobal = polygonVertices.Min(p => p.Y); int yMaxGlobal = polygonVertices.Max(p => p.Y); yMinGlobal = Math.Max(0, yMinGlobal); yMaxGlobal = Math.Min(height - 1, yMaxGlobal); var edgeTable = new Dictionary<int, List<EdgeInfoScanline>>(); for (int i = 0; i < polygonVertices.Count; i++) { Point p1 = polygonVertices[i]; Point p2 = polygonVertices[(i + 1) % polygonVertices.Count]; if (p1.Y == p2.Y) continue; if (p1.Y > p2.Y) { var temp = p1; p1 = p2; p2 = temp; } int yStart = p1.Y; int yEnd = p2.Y; float xAtYStart = p1.X; float inverseSlope = (p2.Y - p1.Y == 0) ? 0 : (float)(p2.X - p1.X) / (p2.Y - p1.Y); EdgeInfoScanline edgeInfo = new EdgeInfoScanline(yEnd, xAtYStart, inverseSlope); if (!edgeTable.ContainsKey(yStart)) { edgeTable[yStart] = new List<EdgeInfoScanline>(); } edgeTable[yStart].Add(edgeInfo); } bmpData = drawingBitmap.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadWrite, drawingBitmap.PixelFormat); int bytesPerPixel = Image.GetPixelFormatSize(drawingBitmap.PixelFormat) / 8; if (bytesPerPixel != 4) { throw new NotSupportedException("Scanline Fill implementado apenas para 32bppArgb."); } int stride = bmpData.Stride; IntPtr ptr = bmpData.Scan0; int byteCount = Math.Abs(stride) * height; byte[] pixels = new byte[byteCount]; Marshal.Copy(ptr, pixels, 0, byteCount); byte[] colorBytes = BitConverter.GetBytes(fillColor.ToArgb()); List<EdgeInfoScanline> activeEdgeTable = new List<EdgeInfoScanline>(); for (int y = yMinGlobal; y < yMaxGlobal; y++) { activeEdgeTable.RemoveAll(edge => edge.YMax == y); if (edgeTable.ContainsKey(y)) { activeEdgeTable.AddRange(edgeTable[y]); } activeEdgeTable.Sort((e1, e2) => e1.XCurrent.CompareTo(e2.XCurrent)); for (int i = 0; i < activeEdgeTable.Count; i += 2) { if (i + 1 < activeEdgeTable.Count) { int xStart = (int)Math.Ceiling(activeEdgeTable[i].XCurrent); int xEnd = (int)Math.Floor(activeEdgeTable[i + 1].XCurrent); xStart = Math.Max(0, xStart); xEnd = Math.Min(width, xEnd); for (int x = xStart; x < xEnd; x++) { int byteIndex = y * stride + x * bytesPerPixel; if (byteIndex >= 0 && byteIndex + bytesPerPixel <= byteCount) { Buffer.BlockCopy(colorBytes, 0, pixels, byteIndex, bytesPerPixel); } } } } foreach (var edge in activeEdgeTable) { edge.XCurrent += edge.InverseSlope; } } Marshal.Copy(pixels, 0, ptr, byteCount); } catch (Exception ex) { Debug.WriteLine($"Erro durante Scanline Fill: {ex.Message}\n{ex.StackTrace}"); MessageBox.Show($"Erro no Scanline: {ex.Message}", "Erro Scanline", MessageBoxButtons.OK, MessageBoxIcon.Error); } finally { if (bmpData != null) { drawingBitmap.UnlockBits(bmpData); } } }

    } // Fim da classe frmPoligonosTransformacoes
}